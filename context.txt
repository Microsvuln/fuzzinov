4.2 Context-aware Document Representation
FreeDom uses a custom intermediate representation called FD-IR
to describe both the syntax and semantics of an HTML document.
FD-IR strictly follows the DOM specification. Hence, a document in
FD-IR can be directly lowered into a real document in plaintext for
testing. More importantly, FD-IR carries the context information
to generate documents with fewer semantic errors.
4.2.1 Document Context. FreeDom maintains two types of contexts in FD-IR to enable context-aware fuzzing.
Global context. FD-IR maintains a tree structure that records all
the elements and their tags and attributes contained in the initial
DOM tree for reference. FD-IR also keeps track of all the available tokens (e.g., class names, CSS counter names, CSS keyframes
FreeDom
Generator
...
CSS Mutator
DOMTree Mutator
JS Mutator
Merger
Fuzzing Engine
Blackbox Fuzzing
Coverage-guided Fuzzing
FD-IR
HTML
Lowering
Execution
Web Browser
Crash
Reports
Corpus
Coverage
Map
Central Server
FD-IR
 §4.2
 §4.4 §4.3.1
 §4.3.3
 §4.3.2
Figure 3: Overview of FreeDom’s architecture and workflow. FD-IR is a context-aware IR for describing HTML documents, which supports random generation and mutation.
names, etc.). Note that the in-tree elements and tokens are separately organized by FD-IR into two maps, which are indexed by
element and token type for performant queries. The global context
serves as a basis for constructing four types of context-dependent
values, summarized in §3.1, in a document.
Local contexts. FD-IR describes a local context for every
JavaScript function, which is used to generate semantically correct
DOM API calls. The local context not only contains a reference
to the global context but also preserves every DOM object locally
defined by a particular API call in a distinct map. Different from
global elements that can be used by any API call in a function,
the local objects are only valid after being defined. Therefore,
FD-IR is also aware of the exact location where (i.e., at which line)
the object is defined in order to support various API mutations
(see §4.3.2) and function merging (see §4.3.3).
4.2.2 Document Representation. We first introduce an important
interface of FD-IR called Value. As the first-class citizen in FD-IR,
Value is implemented to represent all sorts of data values that may
appear in a document, including but not limited to, CSS selectors,
CSS properties, attributes and arguments and return values of API
calls. In particular, a concrete Value involves the definition of three
indispensable methods:
(1) generate(), which specifies how to randomly generate the data
that forms the Value given the global or local context.
(2) mutate(), which defines how to randomly mutate the Value
with the global or local context.
(3) lower(), which describes how to turn the FD-IR Value into the
corresponding text string in a document.
A Value in FD-IR can be built upon one or more sub-Values. For
example, the top code in Figure 4 presents the description of a
CSS filter property. The property itself is an FD-IR Value. And
its value is defined as CSSFilterValue, which is another Value that
can be either literal or context-dependent. Most basic Values like
CSSFilterValue that do not contain any other Values simply mutate
through regeneration. A compound Value such as CSSProperty
selectively mutates its contained Values (Line 6). However, the
FD-IR Values that serve as a part of the context to be referred to
by other Values are immutable once generated. For instance, the
bottom code in Figure 4 describes ReturnValue, which represents a
return value of an API call. Its mutate() method is empty because
its generation introduces a new object into the local context. If
the return value were regenerated, the uses of the object in the
subsequent API calls would become invalid. Another example is
an attributeName attribute that decides the value of its sibling
attributes such as from (see §3.1). Based on Value, FD-IR manages
to describe the three parts of a document as follows.
The DOM tree. As mentioned in §4.2.1, FD-IR intuitively uses
a multi-branch tree to describe the DOM tree, whose nodes are
DOM elements and whose root is the only <body> element. In each
element node, FD-IR records its type, a unique id for reference, a list
of child nodes, and a list of attributes. Each attribute is a particular
Value instance.
CSS rules. FD-IR also records a list of CSS rules in a document.
For each rule, FD-IR maintains a list of CSS selectors and a list of
CSS properties, all of which are Value instances.
Event handlers. FD-IR maintains a list of event handlers for an
HTML document. Among them, one event handler, which is the
onload event handler of the <body> element, is treated specially as
the main event handler. The total number of other event handlers
in a document is predefined by FreeDom, which never increases
during mutation. Each event handler is composed of a list of DOM
API calls and the local context described in §4.2.1. FD-IR supports
all three types of DOM API calls in JavaScript (see §2.1.1). For an
object property read or write, besides the property name, FD-IR
records the accessed object and the return or new property value as
two Value instances. Similarly, for an object method call, in addition
to the method name, FD-IR presents the object, the return value,

and a list of arguments with more Value instances. Note that all
these Values rely on the local context for generation and mutation
and are lowered into corresponding JavaScript code units.
In general, a document in FD-IR is guaranteed to be:
(1) Stateful. FD-IR presents a document in a structural and programmable format rather than in plaintext.
(2) Context-aware. FD-IR carries not only document content but
also context information, including tree hierarchy and available
objects in the global and local scopes.
(3) Extensible. One can introduce more Value instances to support more DOM features effortlessly.
4.3 Context-aware DOM Fuzzing
A document in FD-IR is composed of many Value instances. Fundamentally, FreeDom performs document generation and mutation
in a context-aware manner by systematically calling generate()
and mutate() of specific Values with context information.
4.3.1 Document Generation. To generate a random input, FDg
always starts with a blank document in FD-IR, which only has a
<body> element, an empty main event handler, and a list of empty
event handlers. Then, FDg uses various methods to construct the
document content in the order of a DOM tree, CSS rules, and event
handlers, which involves heavy context queries and updates.
DOM tree generation. Generating the DOM tree in a document
has the highest priority because the tree determines the available
nodes to be styled and manipulated by CSS rules and event handlers,
respectively. In particular, FDg builds a DOM tree by repeatedly
invoking the following three methods.
(1) Gt1: Insert an element. FDg creates a new element and inserts it
as the child of an existing element in the tree. The index of the
new element among all its siblings is random. Depending on
the type of parent, FDg randomly decides the corresponding
element type of the new child by specification. FDg finally adds
the element into the global context.
(2) Gt2: Append an attribute. FDg creates a new attribute that is
owned by an existing element yet is not set. FDg relies on the
global context to generate the innitial value of the attribute,
which is defined as an FD-IR Value. If the attribute value introduces a new token (e.g., class, CSS counters, etc.) during
generation, the global context will be updated correspondingly.
(3) Gt3: Insert a text node. FDg selects an existing element that is
allowed to have text content, generates a random string, and
inserts the string into the tree as a child of the selected element.
CSS Rule Generation. After having the DOM tree in a document,
FDg further generates a list CSS rules. The generation algorithm of
a CSS rule, called Gc1, repeatedly invokes two sub-routines.
(1) Gc2: Append a CSS selector. FDg generates a CSS selector and
adds it into the rule.
(2) Gc3: Append a CSS property. FDg constructs a CSS property and
appends it into the rule.
Both CSS selectors and properties are Value instances that are
generated based on the global context.
Event Handler Generation. FDg fills every event handler in a
document with a sequence of DOM API calls. In the procedure of
appending a random API call to a particular event handler (notated
as Gf
), FDg first queries both global and local contexts for available
DOM objects that can be used as the arguments of an API call in
the current event handler. Then, FDg chooses a satisfiable DOM
API (i.e., the types of all the required arguments of such an API are
supported by the context) defined by the specification and generates
a corresponding API call based on the context. If the API call returns
a new object, the object along with the line number of its definition
is recorded by the current local context.
4.3.2 Single Document Mutation. FDm aims to mutate three different parts of an existing document with various granularities, while
maintaining context information during mutation. We present the
detailed mutation algorithms adopted by FDm as follows.
DOM tree mutation. FDm may call Gt1, Gt2, and Gt3, as described
in §4.3.1, to grow the DOM tree in a document. In addition, FDm
mutates existing nodes in the tree in three ways.
(1) Mt1: Mutate an attribute value. FDm selects an existing attribute
and mutates it as a Value instance based on the global context.
(2) Mt2: Replace an attribute. FDm first selects an element and randomly removes one of its attributes. Then, FDm applies Gt2 to
append a new attribute to the element. Here, FDm never removes an attribute whose value is referred to by other attribute
values (e.g., attributeName of SVG <animate>).
(3) Mt3: Mutate a text node. FreeDom simply selects a text node
and regenerates its string content.
CSS rule mutation. FDm may directly invoke Gc1, Gc2, or Gc3 to
enlarge CSS rules in a document. Meanwhile, the existing CSS rules
can be mutated from the following three aspects.
(1) Mc1: Replace a CSS rule. FDm removes an existing CSS rule from
the document and inserts a new one generated by Gc1.
(2) Mc2: Mutate a CSS selector. FDm selects and mutates a selector
in an existing rule.
(3) Mc3: Mutate a CSS property. FDm selects a CSS property, and
similarly mutates its value.
Event handler mutation. FDm is also able to mutate event handlers in JavaScript. In particular, FDm first randomly selects a target
event handler in the document. Note that main event handler has
a much higher probability to be selected, as it is triggered most of
the time. Besides appending a new API call (i.e., Gf
) to the target
handler, FDm runs the following three mutation methods. (1) Mf1: Insert an API call. FDm first chooses a particular line of
the JavaScript function as the insertion point. After that, FDm
generates a new API call similar to how FDm does in Gf
. The
only difference is that when FDm queries the context for available DOM objects, all the elements in the global context are
still usable. Meanwhile, only the local objects defined above
the insertion point can serve as the arguments of the API call.
The generated API call is eventually placed at the chosen line.
In addition, the line number of the definition of every DOM
object created below the line is incremented by one.
(2) Mf2: Replace an API call. FDm first selects a random line within
the event handler. The original API call at this line is removed.
Then, FDm generates a new API call and inserts it into the
event handler at the line in the exact same way Mf1 does. Note
that FDm avoids removing any API call at a particular line that
returns an object, because the object may be used in the later
API calls and removing such a call introduces reference errors.
(3) Mf3: Mutate API arguments. FDm first randomly selects an existing API call in the event handler and regenerates any of the
arguments of the API call in a random way based on both global
and local contexts.
Table 2 summarizes the document mutation algorithms supported by FDm with examples. FDm assigns each algorithm a specific weight for random sampling at runtime. We empirically set
text-related mutations with low priority, as the exact text content
is generally not crucial to trigger a crash. In general, FDm prefers
to modify existing document content instead of adding new data to
fully explore the states of existing DOM objects and avoid a rapid
increase in testcase sizes.
4.3.3 Document Merging. Besides mutating a single document,
FDm also supports merging two or more documents into a new
document due to the effectiveness of combining existing seed inputs
for testing proven by [19, 20, 54]. Given two documents Da and Db
,
we present a random algorithm to merge Db
into Da part by part.Merging initial DOM trees. First, algorithm 1 presents how FDm
makes Da consume every node of the DOM tree in Db
, which starts
from the direct child elements of Db
’s tree root. For such an element
nb belonging to Db
, FreeDom randomly selects an element node
nt
in Da that has the same type (i.e., tag) and the same or smaller
tree depth. Next, FDm copies every missing attribute and all the
text content from nb
into nt
. In addition, FDm uses an object map
(i.e., ObjectMap in algorithm 1) to record the mapping from nb
to
nt
. The child elements of nb are then recursively merged with the
offspring of nt
in the same way. In this case, nb no longer exists
in the new DOM tree. Sometimes, an element of the same type as
that to be merged with does not exist in Da. Then, FDm directly
inserts nb along with its offspring into a random location in the
DOM tree of Da, which has the same tree depth as nb
. At the end,
FDm records every element that originates from Db and is directly
inserted into Da without merging in Da’s global context.
Merging CSS rules. Second, FDm directly copies the CSS rules
from Db
into Da, which does not involve any merging conflicts.
Merging event handlers. Next, FDm merges the event handlers
in Da and Db
. As every document in FDm is initialized with a fixed
number of event handlers, FDm simply shuffles two paired event
handlers Fa and Fb by inserting every API call from Fb
into a
random line in Fa (see Mf1 in §4.3.2). Note that the relative order
of any two API calls from Fb
is not changed.
Fixing references. FDm finally uses ObjectMap to fix every reference in the new Da that points to an element that originates from
Db but vanishes when merging the DOM trees.
FDm’s merging algorithm ensures that the resulting document
takes on the characteristics of the two input documents such as their
DOM tree hierarchies and API call sequences while not introducing
semantic errors.
4.3.4 Mutation-based DOM Fuzzing. Based on the aforementioned
algorithms, FDm has a straightforward workflow. First, FDm supports bootstrapping with the aid of FDg or restarting from an old
document corpus in FD-IR. FDm is currently incapable of working
with existing documents in plaintext because a transpiler that lifts
them into FD-IR is missing (see §7.1 for further discussion). Given
an input document in FD-IR every time, FDm first starts its mutation
phase, which is iterated 𝑁1 times. During each fuzzing iteration,
FDm mutates the selected document 𝑀 times to generate a new
one for testing. Each time, one of the mutation algorithms listed
in Table 2 is randomly chosen by weight. After 𝑁1 rounds of single
document mutation, if there is no progress in code coverage, FDm
merges the current document with another one randomly selected
from the corpus into a new one for testing. The merging phase
lasts 𝑁2 times. All the newly generated documents during both
phases that increase code coverage are saved into the corpus. Note
that FDm prefers mutation over merging to avoid a rapid growth
in document size. Also, 𝑁1, 𝑁2, and 𝑀 are all configurable and the
heuristic values we use are 50, 5, and 5.


1 class CSSProperty(Value):
2 def __init__(name, value):
3 self.name = name
4 self.value = value
5 def generate(ctx): self.value.generate(ctx)
6 def mutate(ctx): self.value.mutate(ctx)
7 def lower(): return "{}: {}".format(name, lower(value))
8
9 class CSSFilter(CSSProperty):
10 def __init__(name, value):
11 super().__init__("filter", CSSFilterValue())
12
13 # filter: blur(5px) / url(#id)
14 class CSSFilterValue(Value):
15 def generate(ctx):
16 self.ref = None
17 if Random.bool():
18 self.ref = ctx.getElement("SVGFilterElement")
19 if self.ref is not None: return
20 self.value = "blur({})".format(Random.length())
21 def mutate(ctx): generate(ctx)
22 def lower():
23 if self.ref is None: return value
24 else: return "url(#{})".format(self.ref.id)
1 class ReturnValue(Value):
2 def __init__(t):
3 self.type = t
4 self.ref = None
5 def generate(ctx): # Here ctx is the local context
6 if self.ref is None:
7 self.ref = ctx.createObject(self.type)
8 def mutate(ctx): pass
9 def lower(): return self.ref.id

figure 4: Two non-trivial Value instances in FD-IR, including a CSS filter property, whose generation and mutation
depend on the context, and a return value of a DOM API call,
which updates the context when being generated and thus
becomes immutable. Note that a filter property has many
more value choices, which are omitted here



# Before After Wgt. New
Gt1 <select></select>
<select><option></option></select> M
Gt2 <select size="3"></select> M
Mt1 <select size="3"></select>
<select size="0"></select> H ✓
Mt2 <select autofocus=""></select> H ✓
Gt3 <option></option> <option>A</option> L ✓
Mt3 <option>A</option> <option>CCCCC</option> L ✓
Gc1
.class1 {font-size:15px;}
.class1 {font-size:15px;} div {color:red;} M
Mc1 div {color:red;} M ✓
Gc2 .class1, div {font-size:15px;} M
Mc2 div {font-size: 15px;} H ✓
Gc3 .class1 {font-size:15px; color:red;} M
Mc3 .class1 {font-size:1vmin;} H ✓
Gf
var v1 = window.getSelection();
var v1 = window.getSelection(); M var v2 = v1.getRangeAt(0);
Mf1
document.createElement("div"); M ✓
var v1 = window.getSelection();
Mf2 document.createElement("div"); H ✓
Mf3 var v2 = v1.getRangeAt(0); var v2 = v1.getRangeAt(16); H ✓
Wgt.: Weight, H: High, M: Medium, L: Low
Table 2: The examples of the mutation algorithms used by
FDm for three different parts of a document. The Wgt. column indicates the preference of FDm to those algorithms.
We mark the algorithms that are beyond simple appending
and difficult to support by extending old DOM fuzzers.